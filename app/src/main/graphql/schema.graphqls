# Existing schema
type Query {
    #    products(first: Int!, query: String): ProductConnection
    products(first: Int!, query: String): ProductConnection
    customer(id: ID!): Customer
    product(id: ID!): Product
    codeDiscountNodes(first: Int!): CodeDiscountNodeConnection
    HomeProducts(first: Int!): ProductConnection
    draftOrders(query: String!, first: Int): DraftOrderConnection
    customers(first: Int!, query: String): CustomerConnection
    orders(first: Int, query: String): OrderConnection
    order(id: String!): Order


}
type OrderConnection {
    edges: [OrderEdge]
}

type OrderEdge {
    node: Order
}


type CustomerConnection {
    edges: [CustomerEdge]
}

type CustomerEdge {
    node: Customer
}


# Connection type for pagination
type ProductConnection {
    edges: [ProductEdge]
}

# Edge type for pagination
type ProductEdge {
    node: Product
}

# Define the Product type
type Product {
    id: ID!
    title: String!
    description: String
    tags: [String]
    handle: String
    vendor: String
    productType: String
    totalInventory: Int
    images(first: Int!): ImageConnection
    variants(first: Int!): VariantConnection
    media(first: Int): MediaConnection
}

# Connection type for images
type ImageConnection {
    edges: [ImageEdge]
}

# Edge type for images
type ImageEdge {
    node: Image
    url: String
}

# Define the Image type
type Image {
    src: String!
    url: String
}

# Connection type for variants
type VariantConnection {
    edges: [VariantEdge]
}

# Edge type for variants
type VariantEdge {
    node: Variant
}

# Define the Variant type
type Variant {
    id: ID!
    price: String!
    sku: String
    displayName: String
    selectedOptions: [SelectedOption]
}



input CustomerInput {
    email: String
    firstName: String
    lastName: String
    phone: String
    tags: [String]
    id: ID
    metafields: [MetafieldInput]
    addresses: [MailingAddressInput]

}

type Customer {
    id: ID!
    email: String!
    firstName: String
    lastName: String
    phone: String
    address: String
    createdAt: String
    updatedAt: String
    displayName: String
    preferredContactMethod: String
    marketingOptIn: Boolean
    metafields(first: Int): MetafieldConnection
    addresses: [Address]
    defaultAddress: MailingAddress
}


# Connection type for Metafields
type MetafieldConnection {
    edges: [MetafieldEdge!]!
    metafields(first: Int): MetafieldConnection!
    addresses: [Address!]!
}

type MetafieldEdge {
    node: Metafield
}

# New fields for Metafields
type Metafield {
    namespace: String!
    key: String!
    value: String!
    type: String!
    id: ID!
}

input MetafieldInput {
    namespace: String!
    key: String!
    value: String!
    type: String!
}

# Mutations
type Mutation {
    customerCreate(input: CustomerInput!): CustomerCreatePayload
    customerUpdate(input: CustomerInput!): CustomerUpdatePayload  # Added update mutation
    draftOrderCreate(input: DraftOrderInput!): DraftOrderCreatePayload
    draftOrderUpdate(input: DraftOrderInput!, id: ID!): DraftOrderUpdatePayload
    draftOrderDelete(input: DraftOrderDeleteInput!): DraftOrderDeletePayload
    draftOrderComplete(id: ID!): DraftOrderCompletePayload


}
type DraftOrderCompletePayload {
    draftOrder: DraftOrder
    order: Order
    userErrors: [UserError!]!
}

type CustomerCreatePayload {
    customer: Customer
    userErrors: [UserError!]!
}
input DraftOrderDeleteInput {
    id: ID!
}

# Payload type for deleting a draft order
type DraftOrderDeletePayload {
    deletedId: ID
    userErrors: [UserError!]!
}
input CustomerUpdateInput {
    id: ID!
    metafields: [MetafieldInput!]  # Input for updating customer metafields
}

type CustomerUpdatePayload {
    customer: Customer
    userErrors: [UserError!]!
}

type UserError {
    field: [String]
    message: String!
}


# The input type for Mailing Address
input MailingAddressInput {
    address1: String!
    address2: String!
    city: String!
    phone: String!
}

# Type for CodesCount
type CodesCount {
    count: Int!
}

# Type for DiscountCodeBasic
type DiscountCodeBasic {
    title: String!
    summary: String!
}

# Type for DiscountCodeBxgy
type DiscountCodeBxgy {
    title: String!
    codesCount: CodesCount!
}

# Union type for DiscountCode
union DiscountCode = DiscountCodeBasic | DiscountCodeBxgy

# Type for CodeDiscountNode
type CodeDiscountNode {
    id: ID!
    codeDiscount: DiscountCode!
}

# Type for CodeDiscountNode connection
type CodeDiscountNodeConnection {
    nodes: [CodeDiscountNode]
}



# The input type for addresses
input AddressInput {
    address1: String!
    address2: String!
    city: String!
    phone: String!
}


# The type for Mailing Address
type MailingAddress {
    formattedArea: String!
    address1: String!
    address2: String
    city: String
    phone: String
}


# The address type
type Address {
    address1: String!
    address2: String!
    city: String!
    phone: String
#    phone: String!
}

input DraftOrderInput {
    customerId: ID
    email: String
    tags: [String]
    lineItems: [DraftOrderLineItemInput!]
    billingAddress: MailingAddressInput
    appliedDiscount: DraftOrderAppliedDiscountInput
}


input DraftOrderLineItemInput {
    variantId: ID!
    quantity: Int!
}

type DraftOrderUpdatePayload {
    draftOrder: DraftOrder
    userErrors: [UserError!]!
}
input DraftOrderAppliedDiscountInput {
    valueType: DraftOrderAppliedDiscountType
    value: Float
}


type DraftOrderCreatePayload {
    draftOrder: DraftOrder
    userErrors: [UserError!]!
}


type DraftOrder {
    id: ID!
    tags: [String]
    lineItems(first: Int): DraftOrderLineItemConnection
    billingAddress: MailingAddress
    appliedDiscount:DraftOrderAppliedDiscount
    order: Order
}

type DraftOrderAppliedDiscount {
    valueType: DraftOrderAppliedDiscountType
    value:Float

}
enum DraftOrderAppliedDiscountType {
    FIXED_AMOUNT
    PERCENTAGE
}
type Order {
    id: ID!
    name: String!
    createdAt: String!
    billingAddress: Address
    totalPriceSet: MoneyBag
    lineItems(first: Int): LineItemConnection
}

type LineItemConnection {
    edges: [LineItemEdge]
}
type LineItemEdge {
    node: LineItem
}
type LineItem {
    name: String!
    quantity: Int!
    originalUnitPriceSet: MoneyBag
}


type MoneyBag {
    shopMoney: Money
}

type Money {
    amount: String
    currencyCode: String
}

type DraftOrderConnection {
    nodes: [DraftOrder!]!
}

type DraftOrderLineItemConnection {
    nodes: [DraftOrderLineItem!]!
}

type DraftOrderLineItem {
    name: String
    quantity: Int
    title: String
    variant: ProductVariant
}


type ProductVariant {
    id: ID!
    inventoryQuantity: Int
    selectedOptions: [SelectedOption!]!
    price: String
    product: Product
}

type SelectedOption {
    name: String
    value: String
}

type MediaConnection {
    nodes: [Media!]
}

interface Media {
    id: ID!
}

type MediaImage implements Media {
    id: ID!
    image: Image
}